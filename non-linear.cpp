#define _USE_MATH_DEFINES  // здесь лежит нужная нам константа Е
#include <iostream>
#include <cmath>
/*
используется метод касательных(метод Ньютона)
суть в том, чтобы:
1) выделить отрезки, на которых точно существует единственный корень уравнения (делаем аналитически - на бумаге)
2) уточнение корня, те вычисление его с некоторой погрешностью epsilon c помощью известной формулы
*/

// то, что корень единственный получили, исходя из аналитических соображений

using namespace std;


// значение функции в какой-то точке х
double g(double x)
{
	return pow(x, 3) + x * pow(M_E, x) - 10;
}

// значение производной в точке х
double derivative_g(double x)
{
	return (x + 1) * pow(M_E, x) + 3 * x * x;
}

// корни отделили аналитически, сейчас уточняем их
double root(double epsilon, double a)
{
	double xn = a + 50; // число, намного больше xn_next специально чтобы не выполнилось условие выхода из цикла
	double xn_next = a; // правая граница отрезка, на котором единственный корень
	while (abs(g(xn) - g(xn_next)) > epsilon) // условие выбрано, исходя из интенсивного росто функции xe^x, те малым изменениям аргумента будут соответствовать большие изменения значений функции. следовательно если изменения функции будут малы, то значение аргумента будет максимально близко к корню
	{
		xn = xn_next; // запоминаем предыдущее значение х
		xn_next = xn - g(xn) / derivative_g(xn); // известная формула следующего значения х
	}
	return xn;
}

void algorithm()
{
	double segment_border = 2; // правые границы трех отрезков, на которых есть корень
	double epsilon = 0.001; // погрешность (взял произвольно)
	double cur_root = root(epsilon, segment_border); // вычисляем корень на отрезке
	cout << "корень равен " << cur_root << endl;

}

int main()
{
	setlocale(LC_ALL, "Russian");
	algorithm();
}